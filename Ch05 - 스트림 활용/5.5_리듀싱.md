# Reducing

스트림의 여러 요소들을 하나의 결과로 결합하는 과정을 의미한다. 

스트림의 요소들을 조합하여 단일 결과를 생성하는 중요한 개념이다.

리듀스 연산을 이용하면 '메뉴의 모든 칼로리의 합계를 구하시오', '메뉴에서 칼로리가 가장 높은 요리는?' 처럼 모든 스트림 요소를 반복적으로 처리해서 결과를 도출하는 작업을 수행할 수 있다. 

함수형 프로그래밍 언어에서는 종이를 계속해서 접는것과 비슷하다고하여 `fold`라 부른다. 

### **리듀싱 사용 예시**

- **합계 계산**: 숫자 스트림에서 모든 요소의 합계를 구하는 것
- **최댓값 또는 최솟값 찾기**: 스트림에서 최댓값이나 최솟값을 찾는 것
- **문자열 결합**: 문자열 스트림에서 모든 문자열을 결합하여 하나의 문자열을 만드는 것

⇒ 즉, 리듀싱은 스트림을 단일 값으로 요약할 때 유용하다.

### **요소의 합계**

스트림의 **`reduce`** 메소드를 사용하기 전에, 우선 숫자 리스트의 합을 구하는 방법을 for-each 루프를 통해 살펴보자.

아래는 for-each 루프를 이용해 숫자 요소들을 더하는 코드다.

```java
int sum = 0;
for (int x : numbers) {
    sum += x;
}
```

이 코드에서는 **`numbers`** 의 각 요소를 덧셈 연산자로 반복적으로 결합하여 결과를 만든다. 리스트의 숫자들을 반복적으로 더한다.

이를 **`reduce`** 로 변경해보자.

**`reduce`** 가 받는 두 가지 파라미터

- 초기값 (여기서는 0)
- 두 요소를 결합하여 새 값을 생성하는 람다식 (ex: **`(a, b) -> a + b`**)

```java
int sum = numbers.stream().reduce(0, (a,b) -> a + b);
```

메서드 참조로 Integer 클래스의 sum 메서드를 사용하면 더 간결하게 구현가능하다.

```
int sum = numbers.stream().reduce(0, Integer::sum);
```

### **초기값 없는 `reduce`**

**`reduce`** 의 오버로딩된 변형으로, 초기값 없이 이항 연산자만 사용하여 리듀싱을 수행한다.

이 경우 스트림이 비어있을 때 반환할 기본값이 없기 때문에 **`Optional`** 객체를 반환한다.

```java

Optional<Integer> sum = numbers.stream().reduce((a, b) -> (a + b));
```

**`Optional<Integer>`** 를 반환하는 이유는 스트림이 요소를 포함하지 않는 경우 **`reduce`** 연산이 합계를 반환할 수 없기 때문이다.

### **최대값과 최소값 구하기**

**`reduce`** 를 사용하여 스트림의 최대값 또는 최소값을 계산할 수도 있다. 예를 들어, 최대값을 구하기 위해 **`Integer::max`** 를 사용한다.

```java
Optional<Integer> max = numbers.stream().reduce(Integer::max);
```

최소값을 구하기 위해서는 **`Integer.min`** 을 사용한다.

```java
Optional<Integer> min = numbers.stream().reduce(Integer::min)
```

### **`reduce`의 병렬성 및 장점**

**`reduce`** 의 장점 중 하나는 내부 반복을 사용하여 구현되어 있기 때문에, 병렬 처리가 가능하다는 점이다. 병렬 스트림을 사용하면 **`stream()`** 대신 **`parallelStream()`** 을 사용하여 동일한 **`reduce`** 연산을 병렬로 수행할 수 있다.

물론 병렬 처리를 위해서는 연산이 어떤 순서로 실행되더라도 결과가 바뀌지 않는 구조여야한다.

```java
int sum = numbers.parallelStream().reduce(0, Integer::sum);
```