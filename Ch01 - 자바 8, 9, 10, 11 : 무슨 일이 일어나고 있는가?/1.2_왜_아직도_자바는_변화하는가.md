# 1.2 왜 아직도 자바는 변화하는가?

자바는 지난 1995년 첫 베타 버전이 공개된 이후로 경쟁 언어를 대신하며 커다란 생태계를 성공적으로 구축했다.

자바가 어떻게 그러한 성공을 거둘 수 있었는지 살펴보자.

<br>

## 1.2.1 프로그래밍 언어 생태계에서 자바의 위치

자바는 처음부터 많은 유용한 라이브러리를 포함하는 잘 설계된 객체지향 언어로 시작했다.

자바는 처음부터 스레드와 락을 이용한 소소한 동시성도 지원했다(단, 자바의 하드웨어 중립적인 메모리 모델 덕분에 멀티코어 프로세서에서 병렬적으로 수행되는 스레드는 싱글코어에서의 동작과 달리 예기치 못한 상황을 일으킬 수 있다).

코드를 JVM 바이트 코드로 컴파일하는 특징(그리고 모든 브라우저에서 가상 머신 코드를 지원하기) 때문에 자바는 인터넷 애플릿 프로그램의 주요 언어가 되었다.

> 💡 자바는 어떻게 대중적인 프로그래밍 언어로 성장했는가?
>
> 객체지향이 각광받은 이유 두 가지는 다음과 같다.
> - 캡슐화 덕분에 C에 비해 소프트웨어 엔지니어링적인 문제가 훨씬 적다.
> - 객체지향의 정신적인 모델 덕분에 윈도우 95 및 그 이후의 WIMP 프로그래밍 모델에 쉽게 대응할 수 있다.
>
> 이것은 ‘모든 것은 객체다’로 요약할 수 있다. 일단 만들면 모든 곳에서 실행할 수 있다(write-once run-anywhere).

하지만 프로그래밍 언어 생태계에 변화의 바람이 불었다.

프로그래머는 빅데이터(테라바이트 이상의 데이터셋)라는 도전에 직면하게 되었고, 병렬 프로세싱을 활용해야 하는 데 지금까지의 자바로는 충분히 대응할 수 없었다. 자바 8에 추가된 기능은 자바에 없던 완전히 새로운 개념이지만 현재 시장에서 요구하는 기능을 효과적으로 제공한다.

큰 시스템의 설계 방식도 환경 변화의 한 요소다. 최근에는 외부에서 큰 하위시스템 컴포넌트를 추가하고 다른 벤더가 만든 컴포넌트를 이용해 개발하는 사례가 늘어나고 있다. 자바 8, 9에서는 이러한 설계 스타일에 적응할 수 있도록 디폴트 메소드와 모듈을 제공한다.

자바 8 설계의 밑바탕을 이루는 세 가지 프로그래밍 개념을 소개한다.

<br>

## 1.2.2 스트림 처리

스트림이란 한 번에 한 개씩 만들어지는 연속적인 데이터 항목들의 모임이다.

이론적으로 프로그램은 입력 스트림에서 데이터를 한 개씩 읽어들이며 출력 스트림으로 데이터를 한 개씩 기록한다. 즉, 어떤 프로그램의 출력 스트림은 다른 프로그램의 입력 스트림이 될 수 있다.
- 입력 스트림: `System.in`
- 출력 스트림: `System.out`

---

유닉스나 리눅스의 많은 프로그램은 표준 입력에서 데이터를 읽은 다음에, 데이터를 처리하고, 결과를 표준 출력으로 기록한다. 다음 예제는 파일의 단어를 소문자로 바꾼 다음에 사전순으로 단어를 정렬했을 때 가장 마지막에 위치한 세 단어를 출력하는 프로그램이다. 

```bash
cat file1 file2 | tr "[A-Z]" "[a-z]" | sort | tail -3
```

`sort`는 여러 행의 스트림을 입력으로 받아 여러 행의 스트림을 출력으로 만들어낸다. 유닉스에서는 여러 명령을 병렬로 행한다. 따라서 `cat`이나 `tr`이 완료되지 않은 시점에서 `sort`가 행을 처리하기 시작할 수 있다.

![스크린샷 2023-11-14 00 13 15](https://github.com/yummy-cs/modern-java-in-action/assets/67499154/4c0eb0a2-223b-4342-a209-60be967dd1ee)

---

자바 8에서는 `java.util.stream` 패키지에 스트림 API가 추가되었다. 스트림 패키지에 정의된 `Stream<T>`는 `T` 형식으로 구성된 일련의 항목을 의미한다.

이전 예제에서 유닉스 명령어로 복잡한 파이프라인을 구성했던 것처럼 스트림 API는 파이프라인을 만드는 데 필요한 많은 메서드를 제공한다.

스트림 API의 핵심은 기존에는 한 번에 한 항목을 처리했지만 이제 자바 8에서는 우리가 하려는 작업을 데이터베이스 쿼리처럼 고수준으로 추상화해서 일련의 스트림으로 만들어 처리할 수 있다는 것이다. 

또한 스트림 파이프라인을 이용해서 입력 부분을 여러 CPU 코어에 쉽게 할당할 수 있다는 부가적인 이득도 얻을 수 있다. 스레드라는 복잡한 작업을 사용하지 않으면서도 공짜로 병렬성을 얻을 수 있다.

<br>

## 1.2.3 동작 파라미터화로 메서드에 코드 전달하기

자바 8에 추가된 두 번째 프로그램 개념은 코드 일부를 API로 전달하는 기능이다.

우리가 지정하는 대로 정렬 기준을 주려면 sort 메서드에 명령을 내려야 한다. Comparator 객체를 만들어서 sort에 넘겨주는 방법도 있지만 이는 너무 복잡하며 기존 동작을 단순하게 재활용한다는 측면에서도 맞지 않다. 

자바 8에서는 메서드(우리 코드)를 다른 메서드의 인수로 넘겨주는 기능을 제공한다. 이러한 기능을 이론적으로 동작 파라미터화라고 부른다. 

동작 파라미터가 중요한 이유는, compareUsingCustomerId 메서드를 이용해 sort의 동작을 파라미터화했던 것처럼 스트림 API는 연산의 동작을 파라미터화할 수 있는 코드를 전달하는 사상에 기초하기 때문이다.

![스크린샷 2023-11-14 00 33 06](https://github.com/yummy-cs/modern-java-in-action/assets/67499154/a1fe16e1-ed83-4749-8017-6a54dc8c17d0)

<br>

### 1.2.4 병렬성과 공유 가변 데이터

병렬성을 공짜로 얻는 대신, 스트림 메서드로 전달하는 코드의 동작 방식을 조금 바꿔야 한다.

스트림 메서드로 전달하는 코드는 다른 코드와 동시에 실행하더라도 안전하게 실행될 수 있어야 한다. 보통 다른 코드와 동시에 실행하더라도 안전하게 실행할 수 있는 코드를 만들려면 공유된 가변 데이터(shared mutable data)에 접근하지 않아야 한다. 이러한 함수를 다음과 같이 부른다.

- 순수(pure) 함수
- 부작용 없는(side-effect-free) 함수
- 상태 없는(stateless) 함수

---

공유된 변수나 객체가 있으면 병렬성에 문제가 발생한다. 기존의 `synchronized`를 이용해서 공유된 가변 데이터를 보호하는 규칙을 만들 수 있지만, 일반적으로 `synchronized`는 시스템 성능에 악영향을 미친다. 

자바 8 스트림을 이용하면 기존의 자바 스레드 API보다 쉽게 병렬성을 활용할 수 있다. 다중 프로세싱 코어에서 `synchronized`를 사용하면 코드가 순차적으로 실행되어야 하므로 병렬이라는 목적을 무력화시키면서 생각보다 더 비싼 대가를 치러야 할 수 있다.

---

공유되지 않은 가변데이터, 메서드, 함수 코드를 다른 메서드로 전달하는 두 가지 기능은 함수형 프로그래밍 패러다임의 핵심적인 사항이다. 

반면 명령형 프로그래밍 패러다임에서는 일련의 가변 상태로 프로그램을 정의한다. 공유되지 않은 가변 데이터 요구사항이라는 인수를 결과로 반환하는 기능과 관련된다. 즉, 이 요구사항은 수학적인 함수처럼 함수가 정해진 기능만 수행하며 겉으로 보이는 다른 부작용은 일으키지 않음을 의미한다.

<br>

### 1.2.5 자바가 진화해야 하는 이유

지금까지 자바는 진화해왔다. 

- 제네릭의 등장: 컴파일을 할 때 더 많은 에러를 검출할 수 있다.
- `List`가 `List<String>` 등으로 변화: 리스트의 유형을 알 수 있어 가독성이 좋아졌다.
- `Iterator` 대신 `for-each` 루프의 등장: 기존 값을 변화시키는 데 집중했던 고전적인 객체지향에서 벗어나 함수형 프로그래밍으로 다가섰다. 함수형 프로그래밍에서는 우리가 하려는 작업이 최우선시되며 그 작업을 어떻게 수행하는지는 별개의 문제로 취급한다.

언어는 하드웨어나 프로그래머 기대의 변화에 부응하는 방향으로 변화해야 한다.
