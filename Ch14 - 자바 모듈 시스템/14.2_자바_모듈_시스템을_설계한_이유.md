# 14.2 자바 모듈 시스템을 설계한 이유

자바 언어와 컴파일러에 새로운 모듈 시스템이 추가된 이유 설명 <br>
먼저 자바 9 이전의 모듈화 한계를 살펴보고, JDK 라이브러리와 관련한 배경 지식을 제공하고 모듈화가 왜 중요한지 설명

## 14.2.1 모듈화의 한계

자바 9 이전에 패키지와 JAR 수준에서는 `캡슐화`를 거의 지원하지 않음

### 제한된 가시성 제어

자바는 정보를 감출 수 있는 **public, protected, 패키지 수준, private 4가지의 가시성 접근자**를 제공함

패키지 간의 가시성은 어떻게 제어할까? <br>
한 패키지의 클래스와 인터페이스를 다른 패키지로 공개하려면 `public`으로 이들을 선언해야 하기에 클래스와 인터페이스가 모두에게 공개됨 <br>
보안 측면에서 볼 때 코드가 노출되었으므로 코드를 임의로 조작하는 위협에 더 많이 노출될 수 있음

### 클래스 경로

클래스는 모두 컴파일 한 후 보통 한 개의 평범한 JAR 파일에 넣고 클래스 경로에 이 JAR 파일을 추가해 사용 할 수 있음<br>
그러면 JVM이 동적으로 클래스 경로에 정의된 클래스를 필요할 때 읽음


#### 클래스 경로와 JAR 조합의 약점
- 클래스 경로에는 같은 클래스를 구분하는 버전 개념 ❌
  - ex) JSONParser 클래스를 지정할 때 버전 1.0인지 2.0을 사용하는지 지정할 수 없기때문에 어떤 일이 일어날지 예측할 수 없음
- 클래스 경로는 명시적인 의존성을 지원 ❌
  - 한 JAR가 다른 JAR에 포함된 클래스 집합을 사용하라고 명시적으로 의존성을 정의하는 기능을 제공하지 않음. 이 상황에서는 클래스 경로 때문에 어떤 일이 일어나는지 파악하기 어려움

`메이븐`이나 `그레이들` 같은 빌드 도구는 이런 문제를 해결하는데 도움을 줌<br>
하지만, 자바 9 이전에는 자바, JVM 누두고 명시적인 의존성 정의를 지원하지 않음. 이런 문제를 `JAR 지옥` 또는 `클래스 경로 지옥`이라 부르는 사람도 있음

## 14.2.2 거대한 JDK

- **자바 개발 키트(JDK)** : 자바 프로그램을 만들고 실행하는데 도움을 주는 도구의 집합
- 예시
  - 자바 프로그램을 컴파일하는 `javac`
  - 자바애플리케이션을 로드하고 실행하는 `java`
  - 입출력을 포함해 런타임 지원을 제공하는 `JDK 라이브러리`, `컬렉션`, `스트림`

- 자바 8에서는 **컴팩트 프로파일** 이라는 기법을 제시
  - 관련 분야에 따라 JDK 라이브러리가 세 가지 프로파일로 나뉘어 각각 다른 메모리 풋프린터를 제공(그러나 큰 효과 ❌)

- JDK 자체도 모듈화할 수 있는 자바 모듈 시스템 설계의 필요성 제기
- JDK에서 필요한 부분만 골라 사용하고, 클래스 경로를 쉽게 유추할 수 있으며, 플랫폼을 진화시킬 수 있는 강력한 캡슐화를 제공할 새로운 건축 구조가 필요

## 14.2.3 OSGi와 비교

- 자바의 공식 기능은 아니지만 JVM에서 모듈화 애플리케이션을 구현하는 표준으로 자리 잡음

- 특정 OSGi 프레임워크 내에서만 실행됨, 대표적인 아파치 펠릭스, 에퀴녹스가 있음

- 시스템을 재시작하지 않고도 애플리케이션의 다른 하위 부분을 핫스왑할 수 있다는 점이 직소와 다른 OSGi만의 강점
- 번들의 동작에 필요한 외부 패키지가 무엇이며 어떤 내부 패키지가 외부로 노출되어 다른 번들로 제공되는지를 서술하는 텍스트 파일로 각 번들을 정의
- 동시에 프레임워크 내에 같은 번들의 다른 버전을 설치할 수 있음
- OSGi의 각 번들이 자체적인 클래스 로더를 갖는 반면, 자바 9 모듈 시스템의 직소는 애플리케이션당 한 개의 클래스를 사용하므로 버전 제어를 지원하지 않음
