# 7.1 병렬 스트림

병렬 스트림이란 각각의 스레드에서 처리할 수 있도록 스트림 요소를 여러 청크로 분할한 스트림을 말한다.

→ 모든 멀티코어 프로세서가 각각의 청크를 처리하도록 할당할 수 있다.

컬렉션에 `parallelStream`을 호출하면 병렬 스트림이 생성된다.

---

숫자 n을 인수로 받아서 1부터 n까지의 모든 숫자의 합계를 반환하는 메서드를 구현해보자.

전통적인 자바에서는 다음과 같이 반복문으로 이를 구현할 수 있다.

```java
public long iterativeSum(long n) {
  long resut = 0;
  for (long i = 1L; i <= n; i++) {
    retult += 1;
  }
  return result;
}
```

또한 숫자로 이루어진 무한 스트림을 만든 다음에 인수로 주어진 크기로 스트림을 제한하고, 두 숫자를 더하는 `BinaryOperator`로 리듀싱 작업을 수행하는 방법도 있다.

```java
public long sequentialSum(long n) {=
  return Stream.iterate(1L, i -> i + 1) // 무한 자연수 스트림 생성
               .limit(n)                // n개 이하로 제한
               .reduce(0L, Long::sum);  // 모든 숫자를 더하는 스트림 리듀싱 연산
}
```

이러한 메서드들은 특히 n이 커진다면 연산을 병렬로 처리하는 것이 좋을 것이다. 

- 결과 변수는 어떻게 동기화해야 할까?
- 몇 개의 스레드를 사용해야 할까?
- 숫자는 어떻게 생성할까?
- 생성한 숫자는 누가 더할까?

병렬 스트림을 이용하면 모든 문제를 쉽게 해결할 수 있다. 

<br>

## 7.1.1 순차 스트림을 병렬 스트림으로 변환하기

숫자 스트림에 `parallel` 메서드를 호출하면 기존의 함수형 리듀싱 연산(숫자 합게 계산)이 병렬로 처리된다.

```java
public long parallelSum(long n) {
  return Stream.iterate(1L, i -> i + 1)
               .limit(n)
               .parallel() // 스트림을 병렬 스트림으로 변환
               .reduce(0L, Long::sum);
}
```

이 코드와 이전 코드의 다른 점은 스트림이 여러 청크로 분할되어 있다는 것이다. 

따라서 리듀싱 연산을 여러 청크에 병렬로 수행할 수 있다.

마지막으로 리듀싱 연산으로 생성된 부분 결과를 다시 리듀싱 연산으로 합쳐서 전체 스트림의 리듀싱 결과를 도출한다.

![image](https://github.com/yummy-cs/modern-java-in-action/assets/67499154/7fecf7ac-2e28-4a65-aeed-a3a326a312a1)

---

순차 스트림에 `parallel`을 호출해도 사실 스트림 자체에는 아무 변화도 일어나지 않는다.

내부적으로 연산이 병렬로 수행해야 함을 의미하는 boolean 플래그가 설정될 뿐이다.

반대로 `sequential`로 병렬 스트림을 순차 스트림으로 바꿀 수 있다.

→ 이 두 메서드를 이용해서 어떤 연산을 병렬로 실행하고 어떤 연산을 순차로 실행할지 제어할 수 있다.

```java
stream.parallel()
      .filter(...)
      .sequential()
      .map(...)
      .parallel()
      .reduce();
```

`parallel`과 `sequential` 두 메서드 중에서 최종적으로 호출된 메서드가 전체 파이프라인에 영향을 미친다.

따라서 이 예제의 경우 파이프라인이 전체적으로 병렬로 실행된다.

---

지금까지 하나의 연산을 3가지 방법으로 실행하는 방법을 살펴봤다.

- 반복형
- 순차 리듀싱
- 병렬 리듀싱

이들 중 어느 것이 가장 빠른지 확인해보자.

<br>

> ### 💡 병렬 스트림에서 사용하는 스레드 풀 설정
>
> 스트림의 `parallel` 메서드에서 병렬로 작업을 수행하는 스레드는 어디서 생성되고, 몇 개나 생성되며, 그 과정을 어떻게 커스터마이즈할 수 있을까?
>
> 병렬 스트림은 내부적으로 ForkJoinPool을 사용한다.
>
> 기본적으로 ForkJoinPool은 프로세서 수, 즉 `Runtime.getRuntime().availableProcessors()`가 반환하는 값과 같은 스레드를 가진다.
>
> ```java
> System.setProperty("java.util.concurrent.ForkJoinPool.common.parallelism", "12");
> ```
>
> 이 예제는 전역 설정 코드이므로 이후의 모든 병렬 스트림 연산에 영향을 준다.
>
> 현재는 하나의 병렬 스트림에 사용할 수 있는 특정한 값을 지정할 수 없다. 
>
> 일반적으로 기기의 프로세서 수와 같으므로, 특별한 이유가 없다면 ForkJoinPool이 기본값을 그대로 사용하자.

<br>

## 7.1.2 스트림 성능 측정

Java Microbenchmark Harness(JMH)라는 라이브러리를 이용해서 작은 벤치마크를 구현하여 성능을 측정해보자.

JVM으로 실행되는 프로그램을 벤치마크하는 작업은 쉽지 않다. 핫스팟이 바이트코드를 최적화하는데 필요한 준비 시간, 가비지 컬렉터로 인한 오버헤드 등과 같은 요소를 고려해야 하기 때문이다.

JMH은 간단하고 어노테이션 기반 방식을 지원하며, 이를 이용하면 안정적으로 자바 프로그램이나 JVM을 대상으로 하는 다른 언어용 벤치마크를 구현할 수 있다.

`pom.xml` 파일에 몇 가지 의존성을 추가해 프로젝트에서 JMH를 사용할 수 있다.

---

순차적 스트림을 사용하는 메서드를 간단하게 벤치마크 해보자.

```java
// 벤치마크 대상 메서드를 실행하는 데 걸린 평균 시간 측정
@BenchmarkMode(Mode.AverageTime)
// 벤치마크 결과를 밀리초 단위로 출력
@OutputTimeUnit(TimeUnit.MILLISECONDS)
// 4GB의 힙 공간을 제공한 환경에서 2번 벤치마크를 수행하여 결과의 신뢰성 확보
@Fork(2, jvmArgs={"-Xms4G", "-Xmx4G"})
public class ParallelStreamBenchmark {
  private static final long N = 10_000_000L;

  // 벤치마크 대상 메서드
  @Benchmark
  public long sequentialSum() {
    return Stream.iterate(1L, i -> i + 1)
                 .limit(N)
                 .reduce(0L, Long::sum);
  }

  // 매번 벤치마크를 실행한 다음에는 가비지 컬렉터 동작 시도
  @TearDown(Level.Inocation)
  public void tearDown() {
    System.gc();
  }
}
```

이 코드를 실행하면 JMH 명령은 핫스팟이 코드를 최적화할 수 있도록 20번을 실행하며 벤치마크를 준비한 다음, 20번을 더 실행해 최종 결과를 실행한다. 즉, JMH는 기본적으로 20 + 20회 프로그램을 반복 실행한다.

결과는 다음과 같다.

```bash
Benchmark                                 Mode  Cnt    Score      Error   Units
ParallelStreamBenchmark.sequentialSum     avgt   40  121.843  ±   3.062   ms/op
```

---

전통적인 for 루프를 사용해 반복하는 방법을 살펴보자.

더 저수준으로 동작하고, 기본값을 박싱/언박싱할 필요가 없으므로 더 빠를 것이라고 예상할 수 있다.

```bash
Benchmark                                 Mode  Cnt    Score      Error   Units
ParallelStreamBenchmark.iterativeSum      avgt   40    3.278  ±   0.192   ms/op
```

순차적 스트림을 사용하는 버전에 비해 거의 4배가 빠르다.

---

병렬 스트림을 사용하는 방법을 살펴보자.

```bash
Benchmark                                 Mode  Cnt    Score      Error   Units
ParallelStreamBenchmark.parallelSum       avgt   40  604.059  ±  55.288   ms/op
```

멀티 코어 CPU를 활용하지 못하고 순차 버전에 비해 5배나 느린 결과가 나왔다!

위 결과에 대해 두 가지 문제를 발견할 수 있다.

- 반복 결과로 박싱된 객체가 만들어지므로 숫자를 더하려면 언박싱을 해야 한다.
- 반복 작업은 병렬로 수행할 수 있는 독립 단위로 나누기가 어렵다.

---

여기서 두 번째 문제를 주의 깊게 살펴봐야 한다.

우리는 병렬로 수행될 수 있는 스트림 모델이 필요한데, 아래 그림처럼 이전 연산의 결과에 따라 다음 함수의 입력이 달라지는 `iterate` 연산은 청크로 분할하기 어렵다.

<img width="280" alt="Untitled1" src="https://github.com/yummy-cs/modern-java-in-action/assets/67499154/b3cb4245-b302-41d2-ac15-2602def6a6b8">

이와 같은 상황에서는 병렬 리듀싱 연산이 수행되지 않는다. 

리듀싱 과정을 시작하는 시점에 전체 숫자 리스트가 준비되지 않았으므로 스트림을 병렬로 처리할 수 있도록 청크로 분할할 수 없기 때문이다.

즉, 스트림이 병렬로 처리되도록 지시했고 각각의 합계가 다른 스레드에서 수행되었지만 결국 순차처리 방식과 크게 다른 방식이 없으므로 스레드를 할당하는 오버헤드만 증가하게 된다.

이처럼 병렬 프로그래밍을 잘못 사용하면 오히려 전체 프로그램의 성능이 더 나빠질 수도 있다. 

따라서 `parallel` 메서드를 호출했을 때 내부적으로 어떤 일이 일어나는지 꼭 이해하자.

<br>

### 💡 더 특화된 메서드 사용

멀티코어 프로세서를 활용해서 효과적으로 합계 연산을 병렬로 실행하려면 어떻게 해야 할까?

5장에서 `LongStream.rangeClosed`라는 메서드를 소개했다. 이 메서드는 `iterate`에 비해 다음과 같은 장점을 제공한다.

- 기본형 long을 직접 사용하믈 박싱/언박싱 오버헤드가 사라진다.
- 쉽게 청크로 분할할 수 있는 숫자 범위를 생산한다.
    
    예를 들어 1-20 범위의 숫자를 1-5, 6-10, 11-15, 16-20 범위의 숫자로 분할할 수 있다.
    

---

우선 이 메서드를 이용해서 순차 스트림을 처리하는 시간을 측정해보자.

```java
@Benchmark
public long rangedSum() {
  return LongStream.rangeClosed(1, N)
                   .reduce(0L, Long::sum);
}
```

```bash
Benchmark                                 Mode  Cnt    Score      Error   Units
ParallelStreamBenchmark.rangedSum         avgt   40    5.315  ±   0.285   ms/op
```

기존의 `iterate` 팩토리 메서드로 생성한 순차 버전에 비해 숫자 스트림 처리 속도가 더 빠르다.

특화되지 않은 스트림을 처리할 때는 오토박싱, 언박싱 등의 오버헤드를 수반하기 때문이다.

→ 때로는 알고리즘을 병렬화하는 것보다 적절한 자료구조를 선택하는 것이 중요하다!

---

새로운 버전에 병렬 스트림을 적용해보자.

```java
@Benchmark
public long parallelRangedSum() {
  return LongStream.rangeClosed(1, N)
                   .parallel()
                   .reduce(0L, Long::sum);
}
```

```bash
Benchmark                                 Mode  Cnt    Score      Error   Units
ParallelStreamBenchmark.parallelRangedSum avgt   40    2.677  ±   0.214   ms/op
```

드디어 순차 실행보다 빠른 성능을 가지는 병렬 리듀싱을 만들었다. 이번에는 실질적으로 리듀싱 연산이 병렬로 수행된다. 

올바른 자료구조를 선택해야 병렬 실행도 최적의 성능을 발휘할 수 있다는 사실을 확인할 수 있다.

마지막 벤치마크와 첫 번째 벤치마크를 비교하면 20% 정도 빠르다. 

결국 함수형 프로그래밍을 올바르게 사용하면 반복적으로 코드를 실행하는 방법에 비해서 최신 멀티 코어 CPU가 제공하는 병렬 실행의 힘을 직접적으로 얻을 수 있다.

---

하지만 병렬화가 완전 공짜는 아니라는 점을 기억하자.

병렬화를 이용하려면 다음의 과정을 거쳐야 한다.

1. 스트림을 재귀적으로 분할
2. 각 서브스트림을 서로 다른 스레드의 리듀싱 연산으로 할당
3. 이들 결과를 하나의 값으로 합치기

멀티코어 간의 데이터 이동은 생각보다 비싸다. 따라서 코어 간 데이터 전송 시간보다 훨씬 오래 걸리는 작업만 병렬로 다른 코어에서 수행하는 것이 바람직하다.

또한 상황에 따라 쉽게 병렬화를 이용할 수 있거나 혹은 아예 병렬화를 이용할 수 없는 때도 있다.

그리고 스트림을 병렬화해서 코드 실행 속도를 빠르게 하고 싶으면 항상 병렬화를 올바르게 사용하고 있는지 확인해야 한다.

---

## **7.1.3 병렬 스트림의 올바른 사용법**

- 앞서 같은 결과를 갖는 전통적인 for 문, 순차 스트림, 병렬 스트림의 성능을 비교 했을 때, 결국 병렬 스트림을 사용할 때 가장 주의해야 할 점은 스트림에서 병렬 처리할 시, 적절한 자료구조를 사용하는 것과 같은 연산이더라도 어떤 알고리즘을 적용해야 하는지 결정하는 것이 가장 중요하다고 생각할 수 있다.
- 특히, 병렬 스트림의 잘못된 예시 중 가장 흔한 실수는 아래와 같이 공유된 상태의 값을 변경하는 알고리즘을 병렬로 처리하고자 할 때 가 흔하다
    
    ```java
    public long sideEffectSum(long n) {
      Accumlator accumulator = new Accumulator();
      LongStream.rangeClosed(1, n).forEach(accumulator::add);
      return acculator.total;
    }
    
    public class Accumulator {
      public long total = 0;
      public void add(long value) { total += value; }
    }
    ```
    
- 위의 코드는 `total` 초기값에 1부터 n 까지의 수를 순차적으로 더한 결과를 `total` 이 갖도록 하는 연산이다, 해당 연산 절차 자체에는 문제가 없지만 이를 병렬로 처리하고자 할 때 부터 심각한 문제가 생긴다.
- 위의 코드는 공유된 상태 `total` 이라는 누적자를 병렬로 처리하는 순간부터 누적 연산을 구하기 위한 알고리즘 자체가 붕괴 되며, 여러 스레드가 `total` 에 현재 스레드 자신이 처리할 `total+=value` 에 대해 경쟁 상태에 돌입하게 된다.
- 또한 병렬로 처리하는 각각의 스레드가 `accmulator::add` 에 전달하는 `total+=value` 의 값이 매번 바뀌어 정확한 값을 갖지도 않는다.
- 이를 처리하기 위해서 `동기화`로 문제를 해결한다면 이는 결국 병렬처리가 아닌 순차처리가 된다.

---

## **7.1.4 병렬 스트림 효과적으로 사용하기**

- 병렬 스트림을 사용하는지 적절성 여부를 따지기 위해 양적인 기준을 가지고 판단하기는 어렵지만 어떤 상황에 병렬 스트림을 적용해야 하는지 대략적인 **`양적 기준`**과 **`상황에 대한 기준`**을 마련하는 것이 도움이 된다.

> *확신이 서지 않는다면 직접 측정해라!*
> 
- 모든 경우에 병렬 스트림이 순차 스트림보다 빠르지 않다는 것은 앞서 본 벤치 마킹 예시로 확인할 수 있었으며, 병렬 스트림의 수행 과정은 투명하지 않을 때가 많기 때문에 벤치마크로 성능을 직접 확인하여 적용 여부를 판단한다.

<br>

> *박싱을 주의해서 자료형을 결정하라!*
> 
- 자동 박싱, 언박싱은 성능을 저하시킬 수 있는 요소다.
- Java 8 부터는 `IntStream` , `LongStream` , `DoubleStream` 과 같이 기본 형에 특화된 스트림을 제공하기에 적절하게 사용하는 것이 성능을 개선할 수 있다.

<br>

> *순차 스트림보다 병렬 스트림에서 성능이 저하되는 연산을 구분하라!*
> 
- `limit` , `findFirst` 처럼 ***`요소의 순서`*** 에 의존하는 연산은 병렬 스트림에서 비싼 비용이다.
- `findAny` 는 요소의 순서와 상관 없이 연산하기 때문에 병렬 스트림에서 `findFirst` 보다 성능이 좋다.
- `limit` 을 정렬된 병렬 스트림에서 사용하고자 하며, 연산 리소스가 리스트와 같이 순서를 구분할 필요가 없다면 `unordered` 를 호출해 비정렬 스트림을 얻어 `limit` 을 호출하는 것이 효과적이다.
    - 즉, 요소에 대한 순서 보장을 포기한 `limit` 연산을 수행하는 것을 고려할 상황이 있는지 확인하는 것이 중요한 것과 같다.
    - 중복된 요소들을 처리할 때 요소의 순서에 의미가 없는 경우의 예시로 , 로그 데이터에서 특정 이벤트의 발생 횟수를 세는 작업을 수행하는 경우, 각 로그의 처리 시간은 독립적이며 요소의 순서에 의미가 없을 수 있다.

<br>

> *스트림에서 수행하는 전체 파이프 라인 연산 비용을 고려해라!*
> 
- 처리해야 할 요소의 개수가  N개 이고, 하나의 요소를 처리하는 비용이 Q일 때 전체 파이프라인의 비용은 N * Q 이며, Q가 증가 할 때 병렬 스트림으로 성능을 개선할 가능성이 높아짐을 의미한다.
- 비슷한 맥락으로 소량의 데이터를 처리하는데 병렬 스트림을 고려하는 것은 적절하지 않다.

<br>

> *스트림을 구성하는 자료구조가 적절한지 판단해라!*
> 
- 예시로 `ArrayList` 는 `LinkedList` 보다 효율적으로 분할 할 수 있다.
    - `LinkedList` 를 분할 하기 위해서는 모든 요소를 탐색해야 하지만, `ArrayList` 는 요소를 탐색하지 않고도 리스트를 분할 할 수 있다.
        
        ![image](https://github.com/yummy-cs/modern-java-in-action/assets/97209766/fee218f3-0114-4147-bf08-87dbe338a31e)
        
    - `LinkedList` 는 이전 요소에 대한 참조와 다음 요소에 대한 참조값을 가지고 있는 구조기 때문에 모든 요소를 탐색해야 적절한 분할(병렬 스트림으로)이 가능하다 → O(n)
    - `ArrayList` 는 내부 요소의 값을 인덱스로 바로 접근이 가능하기 때문에 바로 분할 할 수 있다. → O(1)
- range Factory Method 로 만들어진 기본형 스트림도 쉽게 분해 할 수 있다.
    - `IntStream` , `LongStream` , `DoubleStream`

- 7.3 에서 소개할 커스텀 `Spliterator` 를 구현해 분해 과정을 완벽하게 제어할 수 있다.

<br>

> *스트림 특성과 파이프 라인의 중간 연산이 스트림의 특성을 어떻게 변경 하는지에 따라 분해 과정의 성능이 달라질 수 있다.*
> 
- 예를 들어, `SIZED` 스트림은 정확이 같은 크기로 스트림을 분할 할 수 있어서 병렬 처리에 효과적이다.
- 반면, `filter` 연산이 있다면, 스트림 길이를 예측할 수 없어 스트림의 병렬 처리의 효과를 알 수 가 없다.
    - 스트림을 병렬로 분할 하기 위해서는 공정하게 요소의 개수를 예측하여 분할 해야 하지만, `fiter` 의 조건에 따라 몇개의 요소가 올지 모르기 때문에 공정한 분할이 불가능 하다.

<br>

> *최종 연산 병합 과정의 비용을 고려해라!*
> 
- 병렬 스트림으로 얻은 성능의 이득이 서브 스트림들의 결과를 합치는 과정에서 상쇄 될 수 있다.

<br>

> *병렬 스트림이 수행되는 내부 인프라 구조를 고려해라!*
> 
- 병렬 스트림 자체는 Java 7 에 추가된 fork/join framwork 로 스트림을 처리하는데, 이는 병렬 스트림 처리를 내부적으로 병렬 가능한 작업들에 대해 재귀적으로 작게 분할 한 뒤, 서브 태스크 각각의 결과를 합쳐 전체 결과를 구하도록 설계 되었다.
- 이처럼 병렬 처리에 대해 실제 내부에서 어떻게 처리하고 있는지 고려하여 적절하게 병렬 스트림을 처리할 수 있다.
- 뒤에서 해당 프레임 워크를 살펴 보자!
