# 11.3 Optional 적용 패턴

## 11.3.1 Optional 객체 만들기

다양한 방법으로 Optional 객체를 만들 수 있다.

### 빈 Optional

`Optinal.empty`로 빈 Optional 객체를 얻을 수 있다.

```java
Optional<Car> optCar = Optional.empty();
```

### null이 아닌 값으로 Optional 만들기

`Optional.of`로 null이 아닌 값을 포함하는 Optional을 만들 수 있다.

```java
Optional<Car> optCar = Optional.of(car);
```
- car가 null이라면 즉시 NFE이 발생함.(Optional을 사용하지 않았다면 car의 프로퍼티에 접근하려 할 때 에러 발생)

### null값으로 Optional 만들기

`Optional.ofNullable`로 null 값을 저장할 수 있는 Optional을 만들 수 있다.

```java
Optional<Car> optCar = Optional.ofNullable(car);
```
- car가 null이면 Optional 객체가 반환

<br>

## 11.3.2 맵으로 Optional의 값을 추출하고 변환하기

예를 들어, 보험회사의 이름을 추출한다고 가정하자. 다음 코드처럼 이름 정보에 접근하기 전에 insurance가 null인지 확인해야한다.

```java
String name = null;
if(insurance != null){
    name = insurance.getName();
}
```

이런 유형의 패턴에서 사용할 수 있도록 Optional은 `map 메서드`를 지원

```java
Optional<Insurance> optInsurance = Optional.ofNullable(insurance);
Optional<String> name = optInsurance.map(Insurance::getName);
```

- Optional의 map 메서드는 스트림의 map과 개념적으로 비슷
- 여기서 Optional 객체를 최대 요소의 개수가 한 개 이하인 데이터 컬렉션으로 생각할 수 있음
- Optional이 값을 포함하면 map의 인수로 제공된 함수가 값을 바꿈
- 비어있으면 아무 일도 일어나지 않음

<br>

## 11.3.3 flatMap으로 Optional 객체 연결

```java
public String getCarInsuranceName(Person person){
    return person.getCar().getInsurance().getName();
}
```

map을 이용해서 코드를 재구현할 수 있다.

```java
Optional<Person> optPerson = Optional.of(person);
Optional<String> name = 
    optPerson.map(Person::getCar)
             .map(Car::getInsurance)
             .map(Insurance::getName);
```

위 코드가 컴파일되지 않는다. 이유는 다음과 같다.
- getCar는 Optional\<Car> 형식의 객체를 반환
- 즉, map 연산의 결과는 Optional<Optional\<Car>>형식의 객체
- getInsurance는 또 다른 Optional 객체를 반환하므로 getInsurance 메서드를 지원하지 않음

---

이 문제를 어떻게 해결할 수 있을까?
바로 **flatMap**을 사용한다.

`flatMap`은 인수로 받은 함수를 적용해서 생성된 각각의 스트림에서 콘텐츠만 남긴다.<br>
즉, 함수를 적용해서 생성된 모든 스트림이 하나의 스트림으로 병합되어 평준화된다.


### Optional로 자동차의 보험회사 이름 찾기

#### 예제 11-5 Optional로 자동차의 보험회사 이름 찾기
```java
public String getCarInsuranceName(Optional<Person> person){
    return person.flatMap(Person::getCar)
                 .flatMap(Car::getInsurance)
                 .map(Insurance::getName)
                 .orElse("Unknown"); //결과 Optional이 비어있으면 기본값 사용
}
```
- null을 확인하느라 조건 분기문을 추가해서 코드를 복잡하게 만들지 않으면서도 쉽게 이해할 수 있는 코드를 완성
- Person 대신 Optional\<Person>을 사용하도록 메서드 인수 형식을 바꿈
- **Optional을 사용하므로 도메인 모델과 관련한 암묵적인 지식에 의존하지 않고 명시적으로 형식 시스템을 정의할 수 있음**

---

### Optional을 이용한 Person/Car/Insurance 참조 체인

![image](https://github.com/yummy-cs/modern-java-in-action/assets/54580802/58f1760e-cb4f-468c-863d-368db7940e0b)

- Person을 Optional로 감싼 다음에 flatMap(Person::getCar)를 호출
- 첫 번째 단계에서는 Optional 내부의 Person에 Function을 적용
    - 여기서는 Person의 getCar 메서드가 Function
    - getCar 메서드는 Optional\<Car>를 반환하므로 Optional 내부의 Person이 OPtional\<Car>로 변환되면서 중첩 Optional이 생성
    - 따라서, flatMap 연산으로 Optional을 평준화함
      - 평준화 과정: 이론적으로 두 Optional을 합치는 기능을 수행하면서 둘 중 하나라도 null이면 빈 Optional을 생성하는 연산
    - flatMap을 빈 Optional에 호출하면 아무 일도 일어나지 않고 그대로 반환
    - 반면, Optional이 Person을 감싸고 있다면 flatMap에 전달된 Func이 Person에 적용됨, Func을 적용한 결과가 이미 Optional이므로 flatMap메서드는 결과를 그대로 반환할 수 있음

- 두 번째 단계도 첫번째 단계와 비슷하게 Optional\<Car>를 Optional\<Insurance>로 변환함
- 세 번째 단계에서는 Optional\<Insurance>를 Optional\<String>으로 변환
  - Insurance.getName()은 String을 반환하므로 flatMap을 사용할 필요X

<br>

- 호출 체인 중 어떤 메서드가 빈 Optional을 반환한다면 전체 결과로 빈 Optional을 반환하고 아니면 관련 보험회사의 이름을 포함하는 Optional을 반환

- 예제의 호출 체인의 결과로 Optional\<String>이 반환되는데 여기에 회사 이름이 저장되어 있을 수도 있고 없을 수도 있음
- 여기서는 비어있을 때 기본값을 제공하는 orElse라는 메서드를 사용, Optional은 기본값을 제공하거나 언랩하는 다양한 메서드를 제공