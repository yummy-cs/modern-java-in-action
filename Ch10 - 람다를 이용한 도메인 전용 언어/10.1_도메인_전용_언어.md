# 10.1 도메인 전용 언어

도메인 전용 언어(DSL)는 작은, 범용이 아니라 특정 도메인을 대상으로 만들어진 특수 프로그래밍 언어다.

예를 들면 다음과 같다.

- Maven은 빌드 과정을 표현하는 DSL로 간주할 수 있다.
- HTML은 웹페이지의 구조를 정의하도록 특화된 언어다.

---

자바로 구현한 DB를 생각해보자. DB 내부에서 주어진 레코드를 디스크의 어디에 저장해야 할지, 테이블의 인덱스를 어떻게 구성할지, 병렬 트랜잭션을 어떻게 처리할지를 계산하는 많은 코드가 존재한다.

“메뉴에서 400 칼로리 이하의 모든 요리를 찾으시오.”와 같은 쿼리를 프로그램으로 구현한다고 가정하자.

```java
// pseudo code
while (block != null) {
    read(block, buffer);
    for (every record in buffer) {
        if (record.calorie < 400) {
            System.out.println(record.name);
        }
    }
    block = buffer.next();
}
```

위 코드에는 두 가지 문제가 있다.

- locking, I/O, 디스크 할당과 같은 지식이 필요하므로 경험이 부족한 프로그래머가 구현하기엔 조금 어렵다.
- 애플리케이션 수준이 아니라 시스템 수준의 개념을 다루어야 한다.

---

SQL의 menu라는 테이블에서 데이터를 찾는 것처럼 `SELECT name FROM menu WHERE calorie < 400`과 같이 표현하면 어떨까? 즉, 자바가 아닌 DSL을 이용해 DB를 조작해보자. 

기술적으로 이런 종류의 DSL을 외부적(external)이라고 한다. 이는 DB가 텍스트로 구현된 SQL 표현식을 파싱하고 평가하는 API를 제공하는 것이 일반적이기 때문이다. 

---

자바의 API 스트림을 이용해 다음처럼 코드를 간단히 줄일 수 있다.

```java
menu.stream()
    .filter(d -> d.getCalories() < 400)
    .map(Dish::getName)
    .forEach(System.out.println)
```

스트림의 API 특성인 메서드 체인을 보통 자바 Loop의 복잡함 제어와 비교해서 유창함을 의미하는 fluent style이라고 부른다. 

> 소프트웨어 공학에서 **플루언트 인터페이스**(fluent interface)는 메소드 체이닝에 상당 부분 기반한 객체 지향 API 설계 메소드이며, 소스 코드의 가독성을 산문과 유사하게 만드는 것이 목적이다. 특히 인터페이스 안에 도메인 특화 언어를 작성한다.
>
> (위키백과)

이런 스타일은 쉽게 DSL에 적용할 수 있다. 위 예제에서 DSL은 외부적이 아니라 내부적이다. 내부적(internal) DSL에서는 위에서 언급한 SQL의 SELECT FROM 구문처럼 애플리케이션 수준의 기본값이 자바 메서드가 사용할 수 있도록 DB를 대표하는 한 개 이상의 클래스 형식으로 노출된다.

---

기본적으로 DSL을 만들려면 애플리케이션 수준 프로그래머에게 어떤 동작이 필요하며 이들을 어떻게 프로그래머에게 제공하는지 고민해야 한다. 또한 시스템 수준의 개념으로 인해 불필요한 오염이 발생하지 않도록 해야 한다.

내부적 DSL에서는 유창하게 코드를 구현할 수 있도록 적절하게 클래스와 메서드를 노출하는 과정이 필요하다. 외부 DSL은 DSL 문법 뿐만 아니라 DSL을 평가하는 parser도 구현해야 한다. 하지만 이를 제대로 구현한다면 숙련도가 떨어지는 프로그래머 일지라도 이해하기 어려운 기존 시스템 수준 코드 환경에서 새 코드를 빠르고 효과적으로 구현할 수 있다.

<br>

# 10.1 도메인 전용 언어

DSL은 특정 비즈니스 도메인의 문제를 해결하려고 만든 언어다. 

- 예를 들어 회계 전용 소프트웨어 애플리케이션을 개발한다고 가정하자. 이 상황에서 비즈니스 도메인에는 통장 입출금 내역서, 계좌 통합과 같은 개념들이 포함된다. 이런 문제를 표현할 수 있는 DSL을 만들 수 있다.
- 자바에서는 도메인을 표현할 수 있는 클래스와 메서드 집합이 필요하다. 즉, DSL이란 특정 비즈니스 도메인을 인터페이스로 만든 API라고 생각할 수 있다.

DSL은 범용 프로그래밍 언어가 아니다. 

- DSL에서 동작과 용어는 특정 도메인에만 국한되므로, 다른 문제는 걱정할 필요가 없고 오직 자신의 앞에 놓인 문제를 어떻게 해결할지에만 집중할 수 있다.

DSL을 이용하면 사용자가 특정 도메인의 복잡성을 더 잘 다룰 수 있다. 

- 저수준 구현 세부 사항 메서드는 클래스의 비공개로 만들어서 저수준 구현 세부 내용을 숨길 수 있다. 그렇게 함으로써 사용자 친화적인 DSL을 만들 수 있다.

도메인 전문가가 저수준 비즈니스 로직을 구현하도록 만드는 것은 DSL의 역할이 아니다. 다음의 두 가지 필요성을 생각하면서 DSL을 개발해야 한다.

- `의사 소통의 왕`: 코드의 의도가 명확히 전달되어야 하며, 프로그래머가 아닌 사람도 이해할 수 있어야 한다. 이런 방식으로 코드가 비즈니스 요구사항에 부합하는지 확인할 수 있다.
- `한번 코드를 구현하지만 여러 번 읽는다`: 가독성은 유지보수의 핵심이다. 즉, 항상 동료가 쉽게 이해할 수 있도록 코드를 구현해야 한다.

<br>

## 10.1.1 DSL의 장점과 단점

DSL을 도메인에 이용하면 약이 되거나 독이 될 수 있다. 

DSL은 코드의 비즈니스 의도를 명확하게 하고 가독성을 높인다는 점에서 약이 된다. 반면 DSL 구현은 코드이므로 올바로 검증하고 유지보수해야 한다는 책임이 따른다. 따라서 DSL의 장점과 비용을 모두 확인해야만 프로젝트에 DSL을 추가하는 것이 투자대비 긍정적인 결과를 가져올 것인지 올바르게 평가할 수 있다.

---

DSL이 제공하는 장점은 다음과 같다.

- `간결함`: API는 비즈니스 로직을 간편하게 캡슐화하므로 반복을 피할 수 있고 코드를 간결하게 만들 수 있다.
- `가독성`: 도메인 영역의 용어를 사용하므로 비도메인 전문가도 코드를 쉽게 이해할 수 있다. 결과적으로 다양한 조직 구성원 간에 코드와 도메인 영역이 공유될 수 있다.
- `유지보수`: 잘 설계된 DSL로 구현한 코드는 쉽게 유지보수하고 바꿀 수 있다. 유지보수는 비즈니스 관련 코드, 즉 가장 빈번하게 바뀌는 애플리케이션 부분에 특히 중요하다.
- `높은 수준의 추상화`: DSL은 도메인과 같은 추상화 수준에서 동작하므로 도메인의 문제와 직접적으로 관련되지 않은 세부 사항을 숨긴다.
- `집중`: 비즈니스 도메인의 규칙을 표현할 목적으로 설계된 언어이므로 프로그래머가 특정 코드에 집중할 수 있다. 결과적으로 생산성이 좋아진다.
- `관심사 분리`: 지정된 언어로 비즈니스 로직을 표현하므로 애플리케이션의 인프라 구조와 관련된 문제들과 독립적으로 비즈니스 관련된 코드에 집중하기가 용이하다. 결과적으로 유지보수가 쉬운 코드를 구현한다.

---

반면, DSL로 인해 다음과 같은 단점도 발생한다.

- `DSL 설계의 어려움`: 간결하게 제한적인 언어에 도메인 지식을 담는 것이 쉬운 작업은 아니다.
- `개발 비용`: 코드에 DSL을 추가하는 작업은 초기 프로젝트에 많은 비용과 시간이 소모되는 작업이다. 또한 DSL의 유지보수와 변경은 프로젝트에 부담을 주는 요소다.
- `추가 우회 계층`: DSL은 추가적인 계층으로 도메인 모델을 감싸며 이 때 계층을 최대한 작게 만들어 성능 문제를 회피한다.
- `새로 배워야 하는 언어`: DSL을 프로젝트에 추가하면 팀이 배워야 하는 언어가 한 개 더 늘어난다는 부담이 있다. 여러 비즈니스 도메인을 다루는 개별 DSL을 사용하는 상황이라면 이들을 유기적으로 동작하도록 합치는 일은 쉬운 일이 아니다. 개별 DSL이 독립적으로 진화할 수 있기 때문이다.
- `호스팅 언어 한계`: 일부 자바 같은 범용 프로그래밍 언어는 장황하고 엄격한 문법을 가졌다. 이러한 언어를 기반으로 만든 DSL은 문법의 제약을 받고 읽기가 어려워 사용자 친화적 DSL을 만들기가 힘들다. 그러나 자바 8의 람다 표현식은 이 문제를 해결할 강력한 새 도구다.

<br>

## 10.1.2 JVM에서 이용할 수 있는 다른 DSL 해결책

DSL의 카테고리를 구분하는 가장 흔한 방법은 마틴 파울러가 소개한 방법으로, 내부 DSL과 외부 DSL을 나누는 것이다. 

- 내부 DSL(임베디드 DSL)은 순수 자바 코드 같은 기존 호스팅 언어를 기반으로 구현한다.
- 외부 DSL(standalone)은 호스팅 언어와는 독립적으로 자체의 문법을 가진다.

여기에 더해, JVM으로 인해 내부 DSL과 외부 DSL의 중간 카테고리에 해당하는 DSL이 만들어질 가능성이 생겼다. 자바가 아니지만 JVM에서 실행되며 더 유연하고 표현력이 강한 언어들도 있다. 이들을 다중 DSL이라고 칭한다.

<br>

### 📌 내부 DSL

내부 DSL이란 자바로 구현한 DSL을 의미한다. 역사적으로 자바는 유연성이 떨어지는 문법 때문에 읽기 쉽고, 간단하고, 표현력 있는 DSL을 만드는 데 한계가 있었다. 람다 표현식이 등장하면서 이 문제가 어느 정도 해결될 수 있었다. 

람다를 적극적으로 활용하면 익명 내부 클래스를 사용해 DSL을 구현하는 것보다 장황함을 크게 줄여 “신호 대비 잡음 비율”을 적정 수준으로 유지하는 DSL을 만들 수 있다. 문자열 목록을 출력하는 예제로 신호 대비 잡음 비율이 무엇을 의미하는지 살펴보자.

```java
List<String> numbers = Arrays.asList("one", "two", "three");
**numbers.forEach**(new Consumer<String>() {
    @Override
    public void **accept**(String s) {
        **System.out.println(s);**
    }
});
```

위 코드에서 굵은 글씨로 표시한 부분이 코드의 잡음이다. 나머지 코드는 특별한 기능을 더하지 않고 문법상 필요한 잡음이다. 

자바 8에서는 이런 잡음이 많이 줄어든다. 다음처럼 익명 내부 클래스를 람다 표현식으로 바꿀 수 있다.

```java
numbers.forEach(s -> System.out.println(s));
```

다음처럼 메서드 참조로 더 간단하게 만들 수 있다.

```java
numbers.forEach(System.out::println);
```

---

사용자가 기술적인 부분을 염두에 두고 있다면 자바를 이용헤 DSL을 만들 수 있다. 자바 문법이 큰 문제가 아니라면, 순수 자바로 DSL을 구현함으로써 다음과 같은 장점을 얻을 수 있다.

- 새로운 패턴과 기술을 배워 DSL을 구현하는 노력이 현저하게 줄어든다.
- 나머지 코드와 함께 DSL을 컴파일할 수 있다. 따라서 다른 언어의 컴파일러를 이용하거나 외부 DSL을 만드는 도구를 사용할 필요가 없으므로 추가 비용이 들지 않는다.
- 개발 팀이 새로운 언어 또는 익숙하지 않고 복잡한 외부 도구를 배울 필요가 없다.
- DSL 사용자는 기존의 자바 IDE를 이용해 자동 완성, 자동 리팩터링 같은 기능을 그대로 즐길 수 있다.
- 한 개의 언어로 한 개의 도메인 또는 여러 도메인을 대응하지 못해 추가로 DSL을 개발해야 하는 상황에서 추가 DSL을 쉽게 합칠 수 있다.

<br>

### 📌 다중 DSL

같은 자바 바이트코드를 사용하는 JVM 기반 프로그래밍 언어를 이용함으로써 DSL 합침 문제를 해결하는 방법을 다중 DSL이라고 한다.

DSL은 프로그래밍 언어의 영향을 받으므로 간결한 DSL을 만드는 데에는 새로운 언어의 특성들이 아주 중요하다. 스칼라, 루비와 같이 유명한 언어나, Kotlin과 같이 단순하고 쉽게 배울 수 있다는 강점을 가진 새 언어들은 모두 JVM에서 실행되는 언어들이다. 이들은 모두 자바보다 젊으며 제약을 줄이고, 간편한 문법을 지향하도록 설계되었다.

---

특히 스칼라는 커링, 임의 변환 등 DSL 개발에 필요한 여러 특성들을 갖췄다. 간단한 예제를 통해 이 기능들을 어떻게 활용할 수 있는지 살펴보자(자세한 문법보다는 자바의 한계를 넘는 방법을 살펴보는 데 집중해서 보자).

```scala
def times(i: Int, f: => Unit): Unit = {
    f                          // 함수 실행
    if (i > 1) times(i - 1, f) // 횟수가 양수이면 횟수를 감소시켜 재귀적으로 times 실행
}
```

스칼라에서는 i가 아주 큰 숫자라 하더라고 자바에서처럼 스택 오버플로 문제가 발생하지 않는다. 꼬리 호출 최적화를 통해 times 함수 호출을 스택에 추가하지 않기 때문이다. 

이 함수를 이용해 다음처럼 “Hello World”를 3번 호출할 수 있다.

```scala
times(3, println("Hello World"))
```

---

times 함수를 커링하거나 두 그룹으로 인수를 놓을 수 있다.

```scala
def times(i: Int)(f: => Unit):Unit = { f
    if (i > 1 times(i - 1)(f)
}
```

여러 번 실행할 명령을 중괄호 안에 넣어 같은 결과를 얻을 수 있다.

```scala
times(3) {
    println("Hello World")
}
```

---

마지막으로 스칼라는 함수가 반복할 인수를 받는 한 함수를 가지면서 int를 익명 클래스로 암묵적 변환하도록 정의할 수 있다. 

```scala
implicit def intToTimes(i: Int) = new { // int를 무명 클래스로 변환하는 암묵적 변환을 의미
    def times(f: => Unit): Unit = { // 이 클래스는 다른 함수 f를 인수로 받는 itmes 함수 한 개만 정의
        def times(i: Int, f: => Unit): Unit = { // 두 번째 times 함수는 가장 가까운 범주에서 정의한 두 개의 인수를 받는 함수를 이용
            f
            if (i > 1) times(i - 1, f)
        }
        times(i, f) // 내부 times 함수 호출
    }
}
```

이런 방식으로 작은 스칼라 내장 DSL 구현 사용자는 다음처럼 “Hello Wolrd”를 3번 출력하는 함수를 실행할 수 있다.

```scala
3 times {
    println("Hello World")
}
```

---

결과적으로 문법적 잡음이 전혀 없으며, 개발자 아닌 사람도 코드를 쉽게 이해할 수 있다. 여기서 숫자 3은 자동으로 컴파일러에 의해 클래스 인스턴스로 변환되며 i 필드에 저장된다. 점 표기법을 이용하지 않고 times 함수를 호출했는데 이때 반복할 함수를 인수로 받는다.

자바로는 비슷한 결과를 얻기 어렵다. 이는 누가 더 DSL 친화적인지를 명확하게 보여준다. 하지만 이 접근 방법은 다음과 같은 불편함도 초래한다.

- 새로운 프로그래밍 언어를 배우거나 팀의 누군가가 이미 해당 기술을 가지고 있어야 한다. 멋진 DSL을 만들려면 이미 기존 언어의 고급 기능을 사용할 수 있는 충분하니 지식이 필요하기 때문이다.
- 두 개 이상의 언어가 혼재하므로 여러 컴파일러로 소스를 빌드하도록 빌드 과정을 개선해야 한다.
- JVM에서 실행되는 거의 모든 언어가 자바와 100% 호환을 주장하고 있지만, 완벽하지 않을 때가 많다. 이런 호환성 때문에 성능이 손실될 때도 있다. 예를 들어 스칼라와 자바 컬렉션을 서로 호환되지 않으므로 상호 컬렉션을 전달하려면 기존 컬렉션을 대상 언어의 API에 맞게 변환해야 한다.

<br>

### 📌 외부 DSL

외부 DSL을 구현하려면 자신만의 문법과 구문으로 새 언어를 설계해야 한다. 새 언어를 파싱하고, 결과를 분석하고, 외부 DSL을 실행할 코드를 만들어야 한다. 정 이 방법을 택해야 한다면 ANTLR 같은 자바 기반 파서 생성기를 이용하면 도움이 된다. 

외부 DSL을 개발하는 가장 큰 장점은 외부 DSL이 제공하는 무한한 유연성이다. 필요한 특성을 완벽하게 제공하는 언어를 설계할 수 있다. 또한 자바로 개발된 인프라 구조 코드와 외부 DSL로 구현한 비즈니스 코드를 명확하게 분리한다는 점도 장점이다. 하지만 이 분리로 인해 DSL과 호스트 언어 사이에 계층이 생기므로 이는 양날의 검과 같다.
