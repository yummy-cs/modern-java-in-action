# 16.5 CompletableFuture의 종료에 대응하는 방법

실전에서 사용하는 다양한 원격 서비스는 얼마나 지연될지 예측하기 어렵다. 서버 부하에서 네트워크 문제에 이르기까지 다양한 지연 요소가 있기 때문이다. 또한 쿼리 당 비용에 따라 애플리케이션이 제공하는 서비스의 질이 달라질 수도 있다.

여러 상점에 정보를 제공했을 때 몇몇 상점은 다른 상점보다 훨씬 먼저 결과를 제공할 가능성이 크다. 이 장에서는 항상 1초를 지연하는 `delay` 대신 0.5~2.5초의 임의의 지연을 흉내내는 메서드 `randomDelay`를 사용한다.

```java
private static final Random random = new Random();

public static void randomDelay() {
    int delay = 500 + random.nextInt(2000);
    try {
        Thread.sleap(delay);
    } catch (InterruptedException e) {
        throw new RuntimeException(e);
    }
}
```

지금까지는 findPrices 메서드를 이용하여 모든 상점에서 가격 정보를 가져온 다음에서야 사용할 수 있었다. 이제 모든 상점에서 가격 정보를 제공할 때까지 기다리지 않고 각 상점에서 가격 정보를 제공할 때마다 즉시 보여줄 수 있는 최저가격 검색 애플리케이션을 만들어보자. 이때 일부 상점은 오래 기다리다 못해 타임아웃이 일어날 수 있다.

<br>

## 16.5.1 최저가격 검색 애플리케이션 리팩터링

우선 모든 가격 정보를 포함할 때까지 리스트 생성을 기다리지 않도록 프로그램을 고쳐야 한다. 그러려면 상점에 필요한 일련의 연산 실행 정보를 포함하는 CompletableFuture의 스트림을 직접 제어해야 한다. 

다음은 Future 스트림을 반환하도록 findPrices 메서드를 리팩터링한 결과다.

```java
public Stream<CompletableFuture<String>> findPricesStream(String product) {
    return shops.stream()
                .map(shop -> CompletableFuture.supplyAsync(() -> shop.getPrice(product), executor))
                .map(future -> future.thenApply(Quote::parse))
                .map(future -> future.thenCompose(quote -> 
                        CompletableFuture.supplyAsync(() -> Discount.applyDiscount(quote, executor)));
```

```java
CompletableFuture[] futures = findPricesSteam("myPhone")
        .map(f -> f.thenAccept(System.out::println))
        .toArray(size -> new CompletableFuture[size]);
CompletableFuture.allOf(futures).join();
```

<br>

## 16.5.2 응용

이제 앞서 구현한 randomDelay로 0.5~2.5초로 임의의 지연을 발생시켜 원격 서비스 호출을 흉내내보자. 위 코드를 실행시키면 예전처럼 가격 정보가 지정된 시간에 나타나지 않을 뿐만 아니라, 상점 가격 정보가 들어오는 대로 결과가 출력된다. 

어떤 부분이 달라졌는지 좀 더 명확하게 확인할 수 있도록 각각의 계산에 소요된 시간을 출력해보자.

```java
long start = System.nanoTime();
CompletableFuture[] futures = findPricesSteam("myPhone27S")
        .map(f -> f.thenAccept(
            s -> System.out.println(s + " (done in " + ((System.nanoTime() - start) / 1_000_000) + " msecs)")))
        .toArray(size -> new CompletableFuture[size]);
CompletableFuture.allOf(futures).join();
System.out.println("All shops have now responded in " + ((System.nanoTime() - start) / 1_000_000) + " msecs");

// BuyItAll price is 184.74 (done in 2005 msecs)
// MyFavoriteShop price is 192.72 (done in 2157 msecs)
// LetsSaveBig price is 135.58 (done in 3001 msecs)
// ShopEasy price is 167.28 (done in 3869 msecs)
// BestPrice price is 110.93 (done in 4188 msecs)
// All shops have now responded in 4188 msecs
```

임의의 지연이 추가되면 마지막 가격 정보에 비해서 처음의 가격 정보를 두 배 빨리 얻는다는 것을 확인할 수 있다.
